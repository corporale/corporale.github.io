<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://corporale.github.io/</id>
    <title>Gridea</title>
    <updated>2019-07-01T08:36:25.800Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://corporale.github.io/"/>
    <link rel="self" href="https://corporale.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://corporale.github.io//images/avatar.png</logo>
    <icon>https://corporale.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[iOS开发-蓝牙4.0-BLE开发(代码篇）]]></title>
        <id>https://corporale.github.io//post/ios-kai-fa-lan-ya-40-ble-kai-fa-dai-ma-pian</id>
        <link href="https://corporale.github.io//post/ios-kai-fa-lan-ya-40-ble-kai-fa-dai-ma-pian">
        </link>
        <updated>2019-07-01T08:34:06.000Z</updated>
        <summary type="html"><![CDATA[<p>上一篇文章我们讲了iOS开发的理论知识，下面我们就从代码开始讲解。</p>
<p><strong>1.CoreBluetooth.framework导入</strong></p>
<p>1.在General-&gt;TARGETS-&gt;Linked Framworks and Libraries中点击添加并选择CoreBluetooth.framework导入。
<img src="https://upload-images.jianshu.io/upload_images/817824-4dcd5541a8909182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">
2.在代码中导入CoreBluetooth.framework                                                                            Swift：import CoreBluetooth                                                                                        Objective-C：#import</p>
<p>3.声明协议：使用CoreBluetooth需要支持CBCentralManagerDelegate（需要蓝牙管理者mgr 管理者可以扫描外围设备）, CBPeripheralDelegate协议（mgr扫描到外设，与外设进行连接断开连接信息交流等一系列反馈回调），即前面所说的中心设备和外围设备，并实现相应方法</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一篇文章我们讲了iOS开发的理论知识，下面我们就从代码开始讲解。</p>
<p><strong>1.CoreBluetooth.framework导入</strong></p>
<p>1.在General-&gt;TARGETS-&gt;Linked Framworks and Libraries中点击添加并选择CoreBluetooth.framework导入。
<img src="https://upload-images.jianshu.io/upload_images/817824-4dcd5541a8909182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">
2.在代码中导入CoreBluetooth.framework                                                                            Swift：import CoreBluetooth                                                                                        Objective-C：#import</p>
<p>3.声明协议：使用CoreBluetooth需要支持CBCentralManagerDelegate（需要蓝牙管理者mgr 管理者可以扫描外围设备）, CBPeripheralDelegate协议（mgr扫描到外设，与外设进行连接断开连接信息交流等一系列反馈回调），即前面所说的中心设备和外围设备，并实现相应方法</p>
<!-- more -->
<p><strong>2.建立一个Central Manager实例进行蓝牙管理</strong></p>
<pre><code>self.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];

一旦设置代理在运行程序的时候，就会调用协议里一个必须要完成的方法：
这个方法是查看中心设备是否打开蓝牙。
#pragma mark - 只要中心管理者初始化 就会触发此代理方法 判断手机蓝牙状态
- (void)centralManagerDidUpdateState:(CBCentralManager *)central
{
    switch (central.state)
    {
            // PoweredOff
        case CBCentralManagerStatePoweredOff:
            break;
            // PoweredOn
        case CBCentralManagerStatePoweredOn: //蓝牙已开启
            // 搜索外设
            [self.centralManager scanForPeripheralsWithServices:nil  options:self.centralManagerOptionDic];
            break;
            // Resetting
        case CBCentralManagerStateResetting:
            break;
            // Unsupported
        case CBCentralManagerStateUnsupported: //不支持蓝牙
            break;
            // Unauthorized
        case CBCentralManagerStateUnauthorized:
            break;
            // Unknown state
        case CBCentralManagerStateUnknown:
            break;
        default:
            break;
    }
}
[manager scanForPeripheralsWithServices:nil options:nil];
第一个参数那里表示扫描带有相关服务的外部设备，例如填写@[[CBUUIDUUIDWithString:@&quot;需要连接的外部设备的服务的UUID&quot;]]，即表示带有需要连接的外部设备的服务的UUID的外部设备，nil表示扫描全部设备；
options处以后细讲，暂时可以写一个@{CBCentralManagerScanOptionAllowDuplicatesKey :@YES}这样的参数，YES表示会让中心设备不断地监听外部设备的消息，NO就是不能。
</code></pre>
<p><strong>3.扫描周边的蓝牙设备</strong></p>
<pre><code>// 1.中心管理者 2.外设 3.外设携带的数据 4.外设发出的蓝牙信号强度
- (void)centralManager:(CBCentralManager *)central
 didDiscoverPeripheral:(CBPeripheral *)peripheral
     advertisementData:(NSDictionary *)advertisementData
                  RSSI:(NSNumber *)RSSI
{
     /*
     peripheral = &lt;CBPeripheral: 0x166668f0 identifier = C69010E7-EB75-E078-FFB4-421B4B951341, Name = &quot;OBand-75&quot;, state = disconnected&gt;, advertisementData = {
     kCBAdvDataChannel = 38;
     kCBAdvDataIsConnectable = 1;
     kCBAdvDataLocalName = OBand;
     kCBAdvDataManufacturerData = &lt;4c69616e 0e060678 a5043853 75&gt;;
     kCBAdvDataServiceUUIDs =     (
     FEE7
     );
     kCBAdvDataTxPowerLevel = 0;
     }, RSSI = -55
     
     */
    
    if ([peripheral.name hasPrefix:@&quot;OBand&quot;]) {
        [self.centralManager stopScan];
        // 在此处对我们的 advertisementData(外设携带的广播数据) 进行一些处理
        // 标记我们的外设,让他的生命周期 = vc
        self.peripheral = peripheral;
        // 发现完之后就是进行连接
        [self.centralManager connectPeripheral:self.peripheral options:nil];
        NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);
    }
}
</code></pre>
<p><strong>4.连接外围设备</strong></p>
<pre><code>// 中心管理者连接外设成功
- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral
{
    NSLog(@&quot;%s, line = %d, %@=连接成功&quot;, __FUNCTION__, __LINE__, peripheral.name);
    // 连接成功之后,可以进行服务和特征的发现
    
    //  设置外设的代理
    self.peripheral.delegate = self;
    
    // 外设发现服务,传nil代表不过滤
    // 这里会触发外设的代理方法 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error
    [self.peripheral discoverServices:nil];
}

// 连接失败
- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(nullableNSError *)error;（连接失败）

// 丢失连接
- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error
{
    NSLog(@&quot;%s, line = %d, %@=断开连接&quot;, __FUNCTION__, __LINE__, peripheral.name);
}
</code></pre>
<p><strong>5.获得外围设备的服务 &amp; 6.获得服务的特征</strong></p>
<pre><code>#pragma mark - CBPeripheralDelegate
- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error{
    
    if (error)
    {
        NSLog(@&quot;error:%@&quot;,error.localizedDescription);
        return ;
    }
    
    for (CBService *service in peripheral.services)
    {
         NSLog(@&quot;Discovered service %@&quot;, service);

        [peripheral discoverCharacteristics:nil forService:service];
    }
}
当我们扫描到特征的时候，就会跳入发现特征的协议方法里去：

// 发现外设服务里的特征的时候调用的代理方法(这个是比较重要的方法，你在这里可以通过事先知道UUID找到你需要的特征，订阅特征，或者这里写入数据给特征也可以)
- (void)peripheral:(CBPeripheral *)peripheral
  didDiscoverCharacteristicsForService:(CBService *)service
                    error:(nullable NSError *)error
{
    
    if (error) {
        NSLog(@&quot;error:%@&quot;,error.localizedDescription);
        return ;
    }
    
    NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);

    // 下面的36F6和36F5根据需求自己定义
    for (CBCharacteristic *characteristic in service.characteristics)
    {
        if ([[[characteristic UUID] UUIDString] isEqualToString:@&quot;36F6&quot;])
        {
            [peripheral setNotifyValue:YES forCharacteristic:characteristic];
        }
        else if([[[characteristic UUID] UUIDString] isEqualToString:@&quot;36F5&quot;] )
        {
            // 记录要之后每次要写入的特征
            writeCBCharacteristic = characteristic;
        }
    }    
}
</code></pre>
<p><strong>7.给外围设备发送数据（也就是写入数据到蓝牙）</strong></p>
<pre><code>发送数据只需要在指定的service和characteristic组合下发送即可，如果是以CBCharacteristicWriteWithResponse模式发送，发送完后还会调用
CBPeripheralDelegate的peripheral:(CBPeripheral *) didWriteValueForCharacteristic:(CBCharacteristic *) error:(NSError *)，实现该协议方法可判断发送是否成功。
以CBCharacteristicWriteWithoutResponse模式则不会有回调。

[connectPeripheral writeValue:data forCharacteristic:writeCBCharacteristic type:CBCharacteristicWriteWithResponse];
//第一个参数是已连接的蓝牙设备 ；第二个参数是要写入到哪个特征； 第三个参数是通过此响应记录是否成功写入

- (void)peripheral:(CBPeripheral *)peripheral
    didWriteValueForCharacteristic:(CBCharacteristic *)characteristic
    error:(nullable NSError *)error
{
    
    if (error)
    {
        NSLog(@&quot;error:%@, %@&quot;,error.localizedDescription, characteristic);
        return ;
    }

    if (!(characteristic.properties &amp; CBCharacteristicPropertyNotify))
    {
        [peripheral readValueForCharacteristic:characteristic];
    }
}
</code></pre>
<p><strong>8.从外围设备读数据</strong></p>
<pre><code>// 更新特征的value的时候会调用 （凡是从蓝牙传过来的数据都要经过这个回调，简单的说这个方法就是你拿数据的唯一方法） 你可以判断是否修改密码成功, 获取电量信息等, 以及getToken(以我工程蓝牙锁为例子)
- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);
    if (characteristic == @&quot;你要的特征的UUID或者是你已经找到的特征&quot;) {
    //characteristic.value就是你要的数据, 类型是NSData, 二进制数据
    }
}

// 如果有写特征将notift设置为yes之后： [peripheral setNotifyValue:YES forCharacteristic:c]，订阅的通知消息会走下面这个接口
- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{}
</code></pre>
<p>以上内容有写的不对的地方，请大家指出，有理解不了的地方可以同我交流。</p>
<p>参考资料:
<a href="https://www.jianshu.com/p/87c30628ddaa">iOS蓝牙开发：蓝牙连接和数据读写
</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS开发-蓝牙4.0-BLE开发(理论篇）]]></title>
        <id>https://corporale.github.io//post/ios-kai-fa-lan-ya-40-ble-kai-fa-li-lun-pian</id>
        <link href="https://corporale.github.io//post/ios-kai-fa-lan-ya-40-ble-kai-fa-li-lun-pian">
        </link>
        <updated>2019-07-01T08:29:59.000Z</updated>
        <summary type="html"><![CDATA[<p>之前公司的项目有用到蓝牙4.0, 趁周末有时间总结下其中的知识点。蓝牙低功耗技术（BLE，Bluetooth Low Energy）使得蓝牙4.0的应用越来越广泛。其中，在iOS中是要用到系统的&lt;CoreBluetooth/CoreBluetooth.h&gt;框架。</p>
<p>蓝牙开发分为中心者模式和管理者模式（也有人说是中心模式和外设模式）：1.常用的就是使用中心者模式作为开发，我们手机作为主机，连接蓝牙外设；2.管理者模式，这个基本用到的比较少，我们手机自己作为外设，自己创建服务和特征，然后有其他的设备连接我们的手机。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前公司的项目有用到蓝牙4.0, 趁周末有时间总结下其中的知识点。蓝牙低功耗技术（BLE，Bluetooth Low Energy）使得蓝牙4.0的应用越来越广泛。其中，在iOS中是要用到系统的&lt;CoreBluetooth/CoreBluetooth.h&gt;框架。</p>
<p>蓝牙开发分为中心者模式和管理者模式（也有人说是中心模式和外设模式）：1.常用的就是使用中心者模式作为开发，我们手机作为主机，连接蓝牙外设；2.管理者模式，这个基本用到的比较少，我们手机自己作为外设，自己创建服务和特征，然后有其他的设备连接我们的手机。</p>
<!-- more -->
<p>基本概念：一个中心设备可以连接多个外部设备，一个外部设备包含一个或多个服务（services），一个服务包含一个或多个特征（characteristic）。其中1.服务可以理解为一个模块的窗口，它是蓝牙外设对外广播一定要有的。2.特征位于服务下面，是具体实现功能的窗口，一般特征都会有value，也就是特征值，特征是与外界交互的最小单位。3.UUID：相当与使用这个模块对映的应用的标识。4.RSSI：信号强度，利用此信息可进行蓝牙测距</p>
<p>流程主要分为以下几步：1、建立中心设备 2、扫描外部设备 3、连接外部设备 4、扫描外备中的服务和特征 5、利用相关的特征与外部设备收发数据。</p>
<p>CoreBluetooth中涉及以下对象类：</p>
<p>CBCentralManager：中心设备类</p>
<p>CBPeripheral：外围设备类</p>
<p>CBCharacteristic：设备特征类</p>
<p>下篇文章会结合实例代码讲解蓝牙开发流程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://corporale.github.io//post/hello-gridea</id>
        <link href="https://corporale.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>