<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://corporale.github.io/</id>
    <title>Gridea</title>
    <updated>2019-07-02T03:11:07.001Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://corporale.github.io/"/>
    <link rel="self" href="https://corporale.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://corporale.github.io//images/avatar.png</logo>
    <icon>https://corporale.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[iOS-集成Firebase发送推送消息到App]]></title>
        <id>https://corporale.github.io//post/ios-ji-cheng-firebase-fa-song-tui-song-xiao-xi-dao-app</id>
        <link href="https://corporale.github.io//post/ios-ji-cheng-firebase-fa-song-tui-song-xiao-xi-dao-app">
        </link>
        <updated>2019-07-01T08:41:35.000Z</updated>
        <summary type="html"><![CDATA[<p>继续集成Firebase</p>
<p>按照教程文档来<a href="https://firebase.google.com/docs/cloud-messaging/ios/client?authuser=0#upload_your_apns_authentication_key">云消息传递文档</a></p>
<p>讲下比较重要的几个步骤</p>
]]></summary>
        <content type="html"><![CDATA[<p>继续集成Firebase</p>
<p>按照教程文档来<a href="https://firebase.google.com/docs/cloud-messaging/ios/client?authuser=0#upload_your_apns_authentication_key">云消息传递文档</a></p>
<p>讲下比较重要的几个步骤</p>
<!-- more -->
<h1 id="上传您的-apns-身份验证密钥">上传您的 APNs 身份验证密钥</h1>
<p>将您的 APNs 身份验证密钥上传到 Firebase。如果您还没有 APNs 身份验证密钥，请参阅<a href="https://firebase.google.com/docs/cloud-messaging/ios/certs?authuser=0">配置 FCM APNs</a>。</p>
<ol>
<li>
<p>在 Firebase 控制台中，在您的项目内依次选择齿轮图标、<strong>项目设置</strong>以及<strong>云消息传递</strong>标签。
<img src="https://corporale.github.io//post-images/1561972359024.png" alt=""></p>
</li>
<li>
<p>在 <strong>iOS 应用配置</strong>下的 <strong>APNs 身份验证密钥</strong>中，点击<strong>上传</strong>按钮。</p>
</li>
<li>
<p>转到您保存密钥的位置，选择该密钥，然后点击<strong>打开</strong>。添加该密钥的密钥 ID（可在 <a href="https://developer.apple.com/membercenter/index.action">Apple Developer Member Center</a> 的 <strong>Certificates, Identifiers &amp; Profiles</strong> 中找到），然后点击<strong>上传</strong>。</p>
</li>
</ol>
<h1 id="在firebase配置苹果开发者后台的文件">在firebase配置苹果开发者后台的文件</h1>
<p><img src="https://corporale.github.io//post-images/1561972380736.png" alt="">
用它推荐的方式, 配置p12文件, 这个跟极光推送配置差不多
<img src="https://corporale.github.io//post-images/1561972396170.png" alt=""></p>
<h1 id="发送通知消息">发送通知消息</h1>
<p><img src="https://corporale.github.io//post-images/1561972413903.png" alt="点击左边的Clound Messaging"></p>
<ol>
<li>
<p>在目标设备上安装并运行该应用。您需要接受权限请求，才能收到远程通知。</p>
</li>
<li>
<p>确保应用在设备的后台中运行。</p>
</li>
<li>
<p>打开<a href="https://console.firebase.google.com/project/_/notification?authuser=0">通知编辑器</a>，并选择<strong>新建消息</strong>。</p>
</li>
<li>
<p>输入消息内容。</p>
</li>
<li>
<p>选择<strong>在设备上测试</strong>。</p>
</li>
<li>
<p>在标签为<strong>添加 FCM 注册令牌</strong>的字段中，输入您在本指南上一部分获得的注册令牌。
<img src="https://corporale.github.io//post-images/1561972441075.png" alt=""></p>
</li>
</ol>
<p>运行项目在下面这个方法可以获取到</p>
<pre><code>func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String) {
        XGPrint(&quot;Firebase registration token: \(fcmToken)&quot;)
        // TODO：将令牌发送到自家服务器,统一推送
        // 注意：每次应用启动时以及每当生成新令牌时都会触发此回调。
    }
</code></pre>
<ol start="7">
<li>点击<strong>测试</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Homebrew 安装历程分享]]></title>
        <id>https://corporale.github.io//post/homebrew-an-zhuang-li-cheng-fen-xiang</id>
        <link href="https://corporale.github.io//post/homebrew-an-zhuang-li-cheng-fen-xiang">
        </link>
        <updated>2019-07-01T08:38:05.000Z</updated>
        <summary type="html"><![CDATA[<p>今天为了跑个从github下载下来的工程, 花了半天时间终于将homebrew和Carthage安装好, 为了后面的人安装可以顺利点,现在将过程中遇到的坑整理下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天为了跑个从github下载下来的工程, 花了半天时间终于将homebrew和Carthage安装好, 为了后面的人安装可以顺利点,现在将过程中遇到的坑整理下。</p>
<!-- more -->
<h1 id="1homebrew介绍">1.Homebrew介绍</h1>
<p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p>
<h1 id="2安装">2.安装</h1>
<p><a href="https://brew.sh/index_zh-cn.html">官网介绍链接</a>
其实就一句命令行，将下面的命令行复制到终端运行就可以</p>
<pre><code>安装命令
/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>心想安装个东西应该没什么问题，结果一开始就报错了</p>
<pre><code>error: RPC failed; curl 18 transfer closed with outstanding read data remaining
fatal: The remote end hung up unexpectedly
fatal: early EOF
fatal: index-pack failed
Failed during: git fetch origin master:refs/remotes/origin/master --tags --force
</code></pre>
<p>百度，翻墙搜索各种方法都试一遍，发现执行安装命令后还是报这个错</p>
<p>后面想到有可能是国内网络问题，ping下github.com, 发现超时，于是去<a href="http://github.global.ssl.fastly.net.ipaddress.com/">这里</a>查询到ip是xxx.xxx.xxx.xxx，之后修改本地的host配置，配置的步骤如下</p>
<ul>
<li>1.在终端中 sudo vi /etc/hosts 打开编辑文件</li>
<li>2.按 s 进入编辑模式</li>
<li>3.接着在最下面添加 xxx.xxx.xxx.xxx github.com</li>
<li>4.按 control + c 保存</li>
<li>5.输入 :wq 退出</li>
</ul>
<p>再次执行安装命令，终端提示 no alternative certificate subject name matches target host name 'github.com', 好吧，应该是host配置不对，后面按照网上大神的<a href="https://www.jianshu.com/p/c8d998903a6a">教程</a>那个xx替换成<strong>192.30.253.113</strong>就没问题</p>
<p>一开始还担心这个ip地址指向的地方是不安全，用<a href="https://www.ip.cn/index.php?ip">ip域名查询</a>下发现指向github,再次执行安装命令，终于成功了
<img src="https://corporale.github.io//post-images/1561971977512.png" alt=""></p>
<p>下篇文章会说怎么用homebrew安装Carthage</p>
<p>参考链接
<a href="https://www.jianshu.com/p/c8d998903a6a">Mac Homebrew 安装遇到的坑</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS-使用Firebase收集应用崩溃日志]]></title>
        <id>https://corporale.github.io//post/ios-shi-yong-firebase-shou-ji-ying-yong-beng-kui-ri-zhi</id>
        <link href="https://corporale.github.io//post/ios-shi-yong-firebase-shou-ji-ying-yong-beng-kui-ri-zhi">
        </link>
        <updated>2019-06-03T11:24:58.000Z</updated>
        <summary type="html"><![CDATA[<p>公司做的项目主要市场是海外， 所以同事提到集成Firebase，可以进行收集日志和分析用户情况。毕竟2014年10月就被Google收购了，结合Google的云服务可以很方便管理自己的项目。</p>
]]></summary>
        <content type="html"><![CDATA[<p>公司做的项目主要市场是海外， 所以同事提到集成Firebase，可以进行收集日志和分析用户情况。毕竟2014年10月就被Google收购了，结合Google的云服务可以很方便管理自己的项目。</p>
<!-- more -->
<h1 id="firebase-crashlytics-使用入门">Firebase Crashlytics 使用入门</h1>
<p>按照官网这个<a href="https://firebase.google.com/docs/crashlytics/get-started?authuser=0">Firebase Crashlytics 使用入门</a>
大概就是
1.首先去<a href="%5Bhttps://console.firebase.google.com/%5D(https://console.firebase.google.com/)">Firebase 控制台</a>创建应用
2.然后进去对应项目后点击左边栏的Crashlytics
<img src="https://corporale.github.io//post-images/1561972134187.png" alt="">
3.按照上面官网提供的链接在CocoaPods添加对应的库，这里就不多说了，教程说得很详细了。之后还有个视频教程，看下来说得挺详细得。
<img src="https://corporale.github.io//post-images/1561972150380.png" alt=""></p>
<h1 id="firebase要想查看崩溃报告还要结合fabric才可以分析">Firebase要想查看崩溃报告还要结合fabric才可以分析</h1>
<p>wtf，还要fabric账号，叫公司的安卓同事又要了个公司的fabric账号
在<a href="https://fabric.io/firebase_migration/apps">fabric首页</a>死活找不到创建app地方。目标就是生成一个app在左边红色框的地方将他拖到右边的地方就进行firebase和fabric的绑定，都已经按照视频的教程做了，晕
<img src="https://corporale.github.io//post-images/1561972977086.png" alt=""></p>
<p>现在问题是怎么才会出现呢，无意中点到<a href="https://fabric.io/settings/organizations">organizations</a>。跳到这个网址<a href="https://fabric.io/kits">这个网址</a>点击第一个地方。
这个才是接下来正常的<a href="https://fabric.io/kits/ios/crashlytics/summary">教程</a>，firebase讲一半不讲一半，也没有引导用户跳到这个网址再进行浏览。按照步骤下来，终于可以愉快玩耍了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[运行iSimulator工程]]></title>
        <id>https://corporale.github.io//post/yun-xing-isimulator-gong-cheng</id>
        <link href="https://corporale.github.io//post/yun-xing-isimulator-gong-cheng">
        </link>
        <updated>2019-03-02T08:54:00.000Z</updated>
        <summary type="html"><![CDATA[<p>上一篇文章说到安装homebrew，这篇文章就说用homebrew安装Carthage遇到的坑。注意：这篇文章以工程<a href="https://github.com/wigl/iSimulator">iSimulator</a>为例子</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一篇文章说到安装homebrew，这篇文章就说用homebrew安装Carthage遇到的坑。注意：这篇文章以工程<a href="https://github.com/wigl/iSimulator">iSimulator</a>为例子</p>
<!-- more -->
<h1 id="1介绍">1.介绍</h1>
<p>Carthage与CocoaPods类似，都是用于在iOS/OS X环境下管理第三方的工具。</p>
<h1 id="2安装carthage">2.安装Carthage</h1>
<pre><code>brew install carthage
</code></pre>
<p>安装Carthage之后, 可以通过下面命令查看版本</p>
<pre><code>carthage version  // 目前的版本号为0.32.0
</code></pre>
<h1 id="3-使用carthage">3. 使用Carthage</h1>
<p>进入项目所在的文件夹</p>
<pre><code>cd ~/路径/项目文件夹
</code></pre>
<p>因为本身我的工程里就有个Cartfile文件，别人已经创建好</p>
<pre><code>./carthageBootstrap.sh
</code></pre>
<p>运行之后提示这个错误</p>
<pre><code>A shell task (/usr/bin/xcrun xcodebuild -project /Users/Corporal/Desktop/iSimulator-develop/Carthage/Checkouts/FBSimulatorControl/FBSimulatorControl.xcodeproj CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES -list) failed with exit code 72:
xcrun: error: unable to find utility &quot;xcodebuild&quot;, not a developer tool or in PATH
</code></pre>
<p>想到我的电脑有两个Xcode, Xcode重命名后，xcodebuild找不到原来的Xcode了所致。</p>
<p>解决方法：在 终端执行如下命令</p>
<pre><code>sudo xcode-select -s /Applications/Xcode.app/Contents/Developer/
</code></pre>
<p>再次执行./carthageBootstrap.sh， 成功
<img src="https://corporale.github.io//post-images/1561972051737.png" alt=""></p>
<h1 id="4运行isimulator">4.运行iSimulator</h1>
<p>折腾半天终于将工程跑成功，但运行完之后控制台提示这个错误, 然后模拟器没有显示出来
Unable to load Info.plist exceptions (eGPUOverrides)</p>
<pre><code>iSimulator[12766:646940] [default] Unable to load Info.plist exceptions (eGPUOverrides)
</code></pre>
<p>环境：Mac系统是mojave10.14, Xcode10
更新到最新的Xcode10.1还是报同样的错，更新到10.14.3中，希望是系统的问题了</p>
<p>18/3/2 18:47编辑
将Mac的系统升到10.14.3运行工程就没有问题了, 虽然也是提示上面这段话, 但模拟器可以跑起来</p>
<h1 id="附">附</h1>
<p>下面贴几个Carthage的使用方法
<a href="https://www.jianshu.com/p/7a0634e14332">Carthage的用法及注意事项</a>
<a href="https://www.jianshu.com/p/1fcee472184c">Carthage使用教程总结 - iOS</a>
<a href="https://www.jianshu.com/p/a734be794019">Carthage的安装和使用</a></p>
<p>参考链接
1.<a href="https://blog.csdn.net/u010411264/article/details/62888873">xcrun: error: unable to find utility &quot;instruments&quot;, not a developer tool or in PATH</a>
2.<a href="https://blog.csdn.net/joeblackzqq/article/details/38908317">xcode-select: error: tool 'xcodebuild' requires Xcode错误解决方法</a>
3.<a href="https://stackoverflow.com/questions/52507950/unable-to-load-info-plist-error-xcode-10-under-macos-10-14-mojave">无法在macOS 10.14 Mojave下加载Info.plist错误Xcode 10</a>
4.<a href="https://forum.openframeworks.cc/t/window-not-drawn-on-startup-using-xcode10/30819">Window not drawn on startup using Xcode10</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS开发-蓝牙4.0-BLE开发(代码篇）]]></title>
        <id>https://corporale.github.io//post/ios-kai-fa-lan-ya-40-ble-kai-fa-dai-ma-pian</id>
        <link href="https://corporale.github.io//post/ios-kai-fa-lan-ya-40-ble-kai-fa-dai-ma-pian">
        </link>
        <updated>2019-02-17T15:34:06.000Z</updated>
        <summary type="html"><![CDATA[<p>上一篇文章我们讲了iOS开发的理论知识，下面我们就从代码开始讲解。</p>
<p><strong>1.CoreBluetooth.framework导入</strong></p>
<p>1.在General-&gt;TARGETS-&gt;Linked Framworks and Libraries中点击添加并选择CoreBluetooth.framework导入。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上一篇文章我们讲了iOS开发的理论知识，下面我们就从代码开始讲解。</p>
<p><strong>1.CoreBluetooth.framework导入</strong></p>
<p>1.在General-&gt;TARGETS-&gt;Linked Framworks and Libraries中点击添加并选择CoreBluetooth.framework导入。</p>
<!-- more -->
<p><img src="https://corporale.github.io//post-images/1561971725495.png" alt="">
2.在代码中导入CoreBluetooth.framework                                                                            Swift：import CoreBluetooth                                                                                        Objective-C：#import</p>
<p>3.声明协议：使用CoreBluetooth需要支持CBCentralManagerDelegate（需要蓝牙管理者mgr 管理者可以扫描外围设备）, CBPeripheralDelegate协议（mgr扫描到外设，与外设进行连接断开连接信息交流等一系列反馈回调），即前面所说的中心设备和外围设备，并实现相应方法</p>
<p><strong>2.建立一个Central Manager实例进行蓝牙管理</strong></p>
<pre><code>self.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];

一旦设置代理在运行程序的时候，就会调用协议里一个必须要完成的方法：
这个方法是查看中心设备是否打开蓝牙。
#pragma mark - 只要中心管理者初始化 就会触发此代理方法 判断手机蓝牙状态
- (void)centralManagerDidUpdateState:(CBCentralManager *)central
{
    switch (central.state)
    {
            // PoweredOff
        case CBCentralManagerStatePoweredOff:
            break;
            // PoweredOn
        case CBCentralManagerStatePoweredOn: //蓝牙已开启
            // 搜索外设
            [self.centralManager scanForPeripheralsWithServices:nil  options:self.centralManagerOptionDic];
            break;
            // Resetting
        case CBCentralManagerStateResetting:
            break;
            // Unsupported
        case CBCentralManagerStateUnsupported: //不支持蓝牙
            break;
            // Unauthorized
        case CBCentralManagerStateUnauthorized:
            break;
            // Unknown state
        case CBCentralManagerStateUnknown:
            break;
        default:
            break;
    }
}
[manager scanForPeripheralsWithServices:nil options:nil];
第一个参数那里表示扫描带有相关服务的外部设备，例如填写@[[CBUUIDUUIDWithString:@&quot;需要连接的外部设备的服务的UUID&quot;]]，即表示带有需要连接的外部设备的服务的UUID的外部设备，nil表示扫描全部设备；
options处以后细讲，暂时可以写一个@{CBCentralManagerScanOptionAllowDuplicatesKey :@YES}这样的参数，YES表示会让中心设备不断地监听外部设备的消息，NO就是不能。
</code></pre>
<p><strong>3.扫描周边的蓝牙设备</strong></p>
<pre><code>// 1.中心管理者 2.外设 3.外设携带的数据 4.外设发出的蓝牙信号强度
- (void)centralManager:(CBCentralManager *)central
 didDiscoverPeripheral:(CBPeripheral *)peripheral
     advertisementData:(NSDictionary *)advertisementData
                  RSSI:(NSNumber *)RSSI
{
     /*
     peripheral = &lt;CBPeripheral: 0x166668f0 identifier = C69010E7-EB75-E078-FFB4-421B4B951341, Name = &quot;OBand-75&quot;, state = disconnected&gt;, advertisementData = {
     kCBAdvDataChannel = 38;
     kCBAdvDataIsConnectable = 1;
     kCBAdvDataLocalName = OBand;
     kCBAdvDataManufacturerData = &lt;4c69616e 0e060678 a5043853 75&gt;;
     kCBAdvDataServiceUUIDs =     (
     FEE7
     );
     kCBAdvDataTxPowerLevel = 0;
     }, RSSI = -55
     
     */
    
    if ([peripheral.name hasPrefix:@&quot;OBand&quot;]) {
        [self.centralManager stopScan];
        // 在此处对我们的 advertisementData(外设携带的广播数据) 进行一些处理
        // 标记我们的外设,让他的生命周期 = vc
        self.peripheral = peripheral;
        // 发现完之后就是进行连接
        [self.centralManager connectPeripheral:self.peripheral options:nil];
        NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);
    }
}
</code></pre>
<p><strong>4.连接外围设备</strong></p>
<pre><code>// 中心管理者连接外设成功
- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral
{
    NSLog(@&quot;%s, line = %d, %@=连接成功&quot;, __FUNCTION__, __LINE__, peripheral.name);
    // 连接成功之后,可以进行服务和特征的发现
    
    //  设置外设的代理
    self.peripheral.delegate = self;
    
    // 外设发现服务,传nil代表不过滤
    // 这里会触发外设的代理方法 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error
    [self.peripheral discoverServices:nil];
}

// 连接失败
- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(nullableNSError *)error;（连接失败）

// 丢失连接
- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error
{
    NSLog(@&quot;%s, line = %d, %@=断开连接&quot;, __FUNCTION__, __LINE__, peripheral.name);
}
</code></pre>
<p><strong>5.获得外围设备的服务 &amp; 6.获得服务的特征</strong></p>
<pre><code>#pragma mark - CBPeripheralDelegate
- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error{
    
    if (error)
    {
        NSLog(@&quot;error:%@&quot;,error.localizedDescription);
        return ;
    }
    
    for (CBService *service in peripheral.services)
    {
         NSLog(@&quot;Discovered service %@&quot;, service);

        [peripheral discoverCharacteristics:nil forService:service];
    }
}
当我们扫描到特征的时候，就会跳入发现特征的协议方法里去：

// 发现外设服务里的特征的时候调用的代理方法(这个是比较重要的方法，你在这里可以通过事先知道UUID找到你需要的特征，订阅特征，或者这里写入数据给特征也可以)
- (void)peripheral:(CBPeripheral *)peripheral
  didDiscoverCharacteristicsForService:(CBService *)service
                    error:(nullable NSError *)error
{
    
    if (error) {
        NSLog(@&quot;error:%@&quot;,error.localizedDescription);
        return ;
    }
    
    NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);

    // 下面的36F6和36F5根据需求自己定义
    for (CBCharacteristic *characteristic in service.characteristics)
    {
        if ([[[characteristic UUID] UUIDString] isEqualToString:@&quot;36F6&quot;])
        {
            [peripheral setNotifyValue:YES forCharacteristic:characteristic];
        }
        else if([[[characteristic UUID] UUIDString] isEqualToString:@&quot;36F5&quot;] )
        {
            // 记录要之后每次要写入的特征
            writeCBCharacteristic = characteristic;
        }
    }    
}
</code></pre>
<p><strong>7.给外围设备发送数据（也就是写入数据到蓝牙）</strong></p>
<pre><code>发送数据只需要在指定的service和characteristic组合下发送即可，如果是以CBCharacteristicWriteWithResponse模式发送，发送完后还会调用
CBPeripheralDelegate的peripheral:(CBPeripheral *) didWriteValueForCharacteristic:(CBCharacteristic *) error:(NSError *)，实现该协议方法可判断发送是否成功。
以CBCharacteristicWriteWithoutResponse模式则不会有回调。

[connectPeripheral writeValue:data forCharacteristic:writeCBCharacteristic type:CBCharacteristicWriteWithResponse];
//第一个参数是已连接的蓝牙设备 ；第二个参数是要写入到哪个特征； 第三个参数是通过此响应记录是否成功写入

- (void)peripheral:(CBPeripheral *)peripheral
    didWriteValueForCharacteristic:(CBCharacteristic *)characteristic
    error:(nullable NSError *)error
{
    
    if (error)
    {
        NSLog(@&quot;error:%@, %@&quot;,error.localizedDescription, characteristic);
        return ;
    }

    if (!(characteristic.properties &amp; CBCharacteristicPropertyNotify))
    {
        [peripheral readValueForCharacteristic:characteristic];
    }
}
</code></pre>
<p><strong>8.从外围设备读数据</strong></p>
<pre><code>// 更新特征的value的时候会调用 （凡是从蓝牙传过来的数据都要经过这个回调，简单的说这个方法就是你拿数据的唯一方法） 你可以判断是否修改密码成功, 获取电量信息等, 以及getToken(以我工程蓝牙锁为例子)
- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);
    if (characteristic == @&quot;你要的特征的UUID或者是你已经找到的特征&quot;) {
    //characteristic.value就是你要的数据, 类型是NSData, 二进制数据
    }
}

// 如果有写特征将notift设置为yes之后： [peripheral setNotifyValue:YES forCharacteristic:c]，订阅的通知消息会走下面这个接口
- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{}
</code></pre>
<p>以上内容有写的不对的地方，请大家指出，有理解不了的地方可以同我交流。</p>
<p>参考资料:
<a href="https://www.jianshu.com/p/87c30628ddaa">iOS蓝牙开发：蓝牙连接和数据读写
</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS开发-蓝牙4.0-BLE开发(理论篇）]]></title>
        <id>https://corporale.github.io//post/ios-kai-fa-lan-ya-40-ble-kai-fa-li-lun-pian</id>
        <link href="https://corporale.github.io//post/ios-kai-fa-lan-ya-40-ble-kai-fa-li-lun-pian">
        </link>
        <updated>2019-02-17T08:29:59.000Z</updated>
        <summary type="html"><![CDATA[<p>之前公司的项目有用到蓝牙4.0, 趁周末有时间总结下其中的知识点。蓝牙低功耗技术（BLE，Bluetooth Low Energy）使得蓝牙4.0的应用越来越广泛。其中，在iOS中是要用到系统的&lt;CoreBluetooth/CoreBluetooth.h&gt;框架。</p>
<p>蓝牙开发分为中心者模式和管理者模式（也有人说是中心模式和外设模式）：1.常用的就是使用中心者模式作为开发，我们手机作为主机，连接蓝牙外设；2.管理者模式，这个基本用到的比较少，我们手机自己作为外设，自己创建服务和特征，然后有其他的设备连接我们的手机。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前公司的项目有用到蓝牙4.0, 趁周末有时间总结下其中的知识点。蓝牙低功耗技术（BLE，Bluetooth Low Energy）使得蓝牙4.0的应用越来越广泛。其中，在iOS中是要用到系统的&lt;CoreBluetooth/CoreBluetooth.h&gt;框架。</p>
<p>蓝牙开发分为中心者模式和管理者模式（也有人说是中心模式和外设模式）：1.常用的就是使用中心者模式作为开发，我们手机作为主机，连接蓝牙外设；2.管理者模式，这个基本用到的比较少，我们手机自己作为外设，自己创建服务和特征，然后有其他的设备连接我们的手机。</p>
<!-- more -->
<p>基本概念：一个中心设备可以连接多个外部设备，一个外部设备包含一个或多个服务（services），一个服务包含一个或多个特征（characteristic）。其中1.服务可以理解为一个模块的窗口，它是蓝牙外设对外广播一定要有的。2.特征位于服务下面，是具体实现功能的窗口，一般特征都会有value，也就是特征值，特征是与外界交互的最小单位。3.UUID：相当与使用这个模块对映的应用的标识。4.RSSI：信号强度，利用此信息可进行蓝牙测距</p>
<p>流程主要分为以下几步：1、建立中心设备 2、扫描外部设备 3、连接外部设备 4、扫描外备中的服务和特征 5、利用相关的特征与外部设备收发数据。</p>
<p>CoreBluetooth中涉及以下对象类：</p>
<p>CBCentralManager：中心设备类</p>
<p>CBPeripheral：外围设备类</p>
<p>CBCharacteristic：设备特征类</p>
<p>下篇文章会结合实例代码讲解蓝牙开发流程。</p>
]]></content>
    </entry>
</feed>